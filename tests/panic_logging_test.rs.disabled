//! Validation for enhanced panic handler with USB logging functionality
//! 
//! This module provides validation functions for the panic handler implementation.
//! It verifies that panic information is correctly logged and USB messages are flushed.
//! Requirements: 5.4, 7.3

#![no_std]
#![no_main]

use ass_easy_loop::logging::{LogQueue, LogLevel, LogMessage, init_global_logging};
use core::panic::PanicInfo;

// Mock timestamp function for testing
fn mock_timestamp() -> u32 {
    12345 // Fixed timestamp for predictable testing
}

/// Validate panic handler logging functionality
/// This function verifies that panic information is correctly logged to the queue
pub fn validate_panic_handler_logging() -> bool {
    // Create a test log queue
    static mut TEST_QUEUE: LogQueue<32> = LogQueue::new();
    
    // Initialize global logging for testing
    unsafe {
        init_global_logging(&mut TEST_QUEUE, mock_timestamp);
    }
    
    // Simulate panic conditions by directly testing the panic logging logic
    // We can't actually trigger a panic in a test, so we test the components
    
    // Test 1: Verify queue is initially empty
    unsafe {
        assert!(TEST_QUEUE.is_empty());
    }
    
    // Test 2: Simulate panic message creation and queuing
    let panic_message = LogMessage::new(
        mock_timestamp(),
        LogLevel::Error,
        "PANIC",
        "PANIC at test.rs:42"
    );
    
    unsafe {
        let enqueue_result = TEST_QUEUE.enqueue(panic_message);
        assert!(enqueue_result, "Failed to enqueue panic message");
        assert_eq!(TEST_QUEUE.len(), 1, "Queue should contain one message");
    }
    
    // Test 3: Verify message content
    unsafe {
        let result = if let Some(logged_message) = TEST_QUEUE.dequeue() {
            assert_eq!(logged_message.level, LogLevel::Error);
            assert_eq!(logged_message.module_str(), "PANIC");
            assert!(logged_message.message_str().contains("PANIC at test.rs:42"));
            assert_eq!(logged_message.timestamp, mock_timestamp());
            true
        } else {
            panic!("Expected to dequeue a panic message");
        };
        assert!(result);
        result
    }
}

/// Test panic handler message formatting
/// Verifies that panic messages are correctly formatted with location information
#[test]
fn test_panic_message_formatting() {
    use heapless::String;
    use core::fmt::Write;
    
    // Test formatting with location information
    let mut panic_msg: String<48> = String::new();
    let test_file = "src/main.rs";
    let test_line = 123u32;
    
    let _ = write!(
        &mut panic_msg,
        "PANIC at {}:{}",
        test_file.split('/').last().unwrap_or("unknown"),
        test_line
    );
    
    assert_eq!(panic_msg.as_str(), "PANIC at main.rs:123");
    
    // Test formatting without location information
    let mut panic_msg_no_loc: String<48> = String::new();
    let _ = write!(&mut panic_msg_no_loc, "PANIC at unknown location");
    
    assert_eq!(panic_msg_no_loc.as_str(), "PANIC at unknown location");
}

/// Test USB message flushing timeout mechanism
/// Verifies that the flush function doesn't hang indefinitely
#[test]
fn test_usb_flush_timeout() {
    // Create a test log queue with some messages
    static mut FLUSH_TEST_QUEUE: LogQueue<8> = LogQueue::new();
    
    // Fill the queue with test messages
    unsafe {
        for i in 0..8 {
            let test_message = LogMessage::new(
                i as u32,
                LogLevel::Info,
                "TEST",
                "Test message for flush"
            );
            FLUSH_TEST_QUEUE.enqueue(test_message);
        }
        
        assert_eq!(FLUSH_TEST_QUEUE.len(), 8, "Queue should be full");
    }
    
    // Simulate the flush operation (simplified version)
    const FLUSH_TIMEOUT_LOOPS: u32 = 1000; // Smaller timeout for testing
    let mut timeout_counter = 0u32;
    
    unsafe {
        // Simulate flushing messages with timeout
        while !FLUSH_TEST_QUEUE.is_empty() && timeout_counter < FLUSH_TIMEOUT_LOOPS {
            if FLUSH_TEST_QUEUE.dequeue().is_some() {
                // Message "flushed" (dequeued)
            }
            timeout_counter += 1;
        }
        
        // Verify that all messages were flushed or timeout occurred
        assert!(FLUSH_TEST_QUEUE.is_empty() || timeout_counter >= FLUSH_TIMEOUT_LOOPS);
        assert!(timeout_counter < FLUSH_TIMEOUT_LOOPS, "Flush should complete before timeout");
    }
}

/// Test panic handler graceful degradation
/// Verifies that panic handler works even when logging system is not initialized
#[test]
fn test_panic_handler_graceful_degradation() {
    // Test that panic handler doesn't crash when global queue is not initialized
    // This simulates the case where panic occurs before logging system initialization
    
    // We can't directly test the panic handler without triggering a panic,
    // but we can test the conditions it checks
    
    // Test 1: Verify behavior when global queue is None
    // (This would be the case before initialization)
    
    // Test 2: Verify behavior when timestamp function is None
    // (This would also be the case before initialization)
    
    // Since we can't easily test the actual panic handler without causing a panic,
    // we verify that the components it uses are robust
    
    // Test message creation with edge cases
    let edge_case_message = LogMessage::new(
        0, // Zero timestamp
        LogLevel::Error,
        "", // Empty module name
        "" // Empty message
    );
    
    assert_eq!(edge_case_message.timestamp, 0);
    assert_eq!(edge_case_message.level, LogLevel::Error);
    assert_eq!(edge_case_message.module_str(), "");
    assert_eq!(edge_case_message.message_str(), "");
}

/// Test panic handler with payload messages
/// Verifies that panic payload messages are correctly handled and logged
#[test]
fn test_panic_handler_with_payload() {
    use heapless::String;
    use core::fmt::Write;
    
    // Simulate panic payload message handling
    let test_payload = "Division by zero";
    let mut payload_msg: String<48> = String::new();
    let _ = write!(&mut payload_msg, "Panic msg: {}", test_payload);
    
    assert_eq!(payload_msg.as_str(), "Panic msg: Division by zero");
    
    // Test payload message truncation for long messages
    let long_payload = "This is a very long panic message that exceeds the maximum length";
    let mut long_payload_msg: String<48> = String::new();
    let _ = write!(&mut long_payload_msg, "Panic msg: {}", long_payload);
    
    // Verify that the message was truncated to fit the buffer
    assert!(long_payload_msg.len() <= 48);
    assert!(long_payload_msg.as_str().starts_with("Panic msg: This is a very long panic"));
}

/// Test system state logging during panic
/// Verifies that system state information is correctly logged
#[test]
fn test_panic_system_state_logging() {
    use heapless::String;
    use core::fmt::Write;
    
    // Test system state message creation
    let mut state_msg: String<48> = String::new();
    let _ = write!(&mut state_msg, "System halted due to panic");
    
    assert_eq!(state_msg.as_str(), "System halted due to panic");
    
    // Create a log message for system state
    let state_log = LogMessage::new(
        mock_timestamp() + 2,
        LogLevel::Error,
        "PANIC",
        state_msg.as_str()
    );
    
    assert_eq!(state_log.level, LogLevel::Error);
    assert_eq!(state_log.module_str(), "PANIC");
    assert_eq!(state_log.message_str(), "System halted due to panic");
    assert_eq!(state_log.timestamp, mock_timestamp() + 2);
}

/// Integration test for complete panic logging sequence
/// Tests the full sequence of panic logging including multiple messages
#[test]
fn test_complete_panic_logging_sequence() {
    // Create a test log queue
    static mut SEQUENCE_TEST_QUEUE: LogQueue<32> = LogQueue::new();
    
    // Initialize global logging for testing
    unsafe {
        init_global_logging(&mut SEQUENCE_TEST_QUEUE, mock_timestamp);
    }
    
    // Simulate the complete panic logging sequence
    let timestamp = mock_timestamp();
    
    // 1. Main panic message
    let panic_log = LogMessage::new(
        timestamp,
        LogLevel::Error,
        "PANIC",
        "PANIC at main.rs:123"
    );
    
    // 2. Payload message
    let payload_log = LogMessage::new(
        timestamp + 1,
        LogLevel::Error,
        "PANIC",
        "Panic msg: Clock initialization failed"
    );
    
    // 3. System state message
    let state_log = LogMessage::new(
        timestamp + 2,
        LogLevel::Error,
        "PANIC",
        "System halted due to panic"
    );
    
    // Enqueue all messages
    unsafe {
        assert!(SEQUENCE_TEST_QUEUE.enqueue(panic_log));
        assert!(SEQUENCE_TEST_QUEUE.enqueue(payload_log));
        assert!(SEQUENCE_TEST_QUEUE.enqueue(state_log));
        
        assert_eq!(SEQUENCE_TEST_QUEUE.len(), 3, "Should have 3 panic messages");
    }
    
    // Verify messages in order
    unsafe {
        // First message: main panic
        if let Some(msg1) = SEQUENCE_TEST_QUEUE.dequeue() {
            assert_eq!(msg1.timestamp, timestamp);
            assert!(msg1.message_str().contains("PANIC at main.rs:123"));
        } else {
            panic!("Expected first panic message");
        }
        
        // Second message: payload
        if let Some(msg2) = SEQUENCE_TEST_QUEUE.dequeue() {
            assert_eq!(msg2.timestamp, timestamp + 1);
            assert!(msg2.message_str().contains("Panic msg: Clock initialization failed"));
        } else {
            panic!("Expected payload message");
        }
        
        // Third message: system state
        if let Some(msg3) = SEQUENCE_TEST_QUEUE.dequeue() {
            assert_eq!(msg3.timestamp, timestamp + 2);
            assert!(msg3.message_str().contains("System halted due to panic"));
        } else {
            panic!("Expected system state message");
        }
        
        assert!(SEQUENCE_TEST_QUEUE.is_empty(), "Queue should be empty after dequeuing all messages");
    }
}

// Panic handler removed - conflicts with std in test mode